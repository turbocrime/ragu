use ff::PrimeField;

use alloc::{vec, vec::Vec};

/// Radix-2 evaluation domain for polynomials in fields supported by Ragu.
pub struct Domain<F> {
    /// $n$, the size of the domain
    n: usize,
    /// $\log_2(n)$
    log2_n: u32,
    /// The primitive $n$-th root of unity in the field
    omega: F,
    /// Inverse of the primitive $n$-th root of unity in the field
    omega_inv: F,
    /// Inverse of $n$ in the field (as an integer) for inverse FFTs
    n_inv: F,
}

impl<F: PrimeField> Default for Domain<F> {
    fn default() -> Self {
        Domain {
            log2_n: F::S,
            n: 1 << F::S,
            omega: F::ROOT_OF_UNITY,
            omega_inv: F::ROOT_OF_UNITY_INV,
            n_inv: (F::TWO_INV).pow_vartime([F::S as u64]),
        }
    }
}

impl<F: PrimeField> Domain<F> {
    /// Initializes a new domain of size $2^k$.
    ///
    /// # Panics
    ///
    /// Panics if attempting to create a domain larger than supported by the
    /// field.
    pub fn new(k: u32) -> Self {
        if k > F::S {
            panic!(
                "tried to create a domain of size 2^{} in a field with 2-adicity {}",
                k,
                F::S
            );
        }

        let mut tmp = Self::default();
        for _ in k..F::S {
            tmp = tmp.halve();
        }
        assert_eq!(k, tmp.log2_n);
        tmp
    }

    /// Halves the size of the evaluation domain.
    ///
    /// # Panics
    ///
    /// Panics if attempting to halve a domain of size 1.
    fn halve(&self) -> Self {
        if self.log2_n == 0 {
            panic!("cannot halve a domain of size 1");
        }

        let log2_n = self.log2_n - 1;
        Domain {
            log2_n,
            n: 1 << log2_n,
            omega: self.omega.square(),
            omega_inv: self.omega_inv.square(),
            n_inv: self.n_inv.double(),
        }
    }

    /// The size of the domain.
    pub fn n(&self) -> usize {
        self.n
    }

    /// The $\log_2(n)$ of this domain of size $n$.
    pub fn log2_n(&self) -> u32 {
        self.log2_n
    }

    /// Returns the generator of the domain.
    pub fn omega(&self) -> F {
        self.omega
    }

    /// Computes the radix2 Fast Fourier Transform (FFT) of a slice using the
    /// Cooley-Tukey algorithm.
    ///
    /// # Panics
    ///
    /// This will panic if the length is not the power of two specified by
    /// `log2_n`.
    pub fn fft(&self, input: &mut [F]) {
        self.fft_inner(input, self.omega);
    }

    /// Performs the inverse operation of [`Self::fft`].
    ///
    /// # Panics
    ///
    /// This will panic if the length is not the power of two specified by
    /// `log2_n`.
    pub fn ifft(&self, input: &mut [F]) {
        self.fft_inner(input, self.omega_inv);

        for input in input.iter_mut() {
            *input *= self.n_inv;
        }
    }

    fn fft_inner(&self, input: &mut [F], omega: F) {
        fn bitreverse(mut n: u32, l: u32) -> u32 {
            let mut r = 0;
            for _ in 0..l {
                r = (r << 1) | (n & 1);
                n >>= 1;
            }
            r
        }

        assert_eq!(input.len(), 1 << self.log2_n);
        let n = input.len() as u32;

        for i in 0..n {
            let ri = bitreverse(i, self.log2_n);
            if i < ri {
                input.swap(ri as usize, i as usize);
            }
        }

        let mut m = 1;
        for _ in 0..self.log2_n {
            let w_m = omega.pow([(n / (m << 1)) as u64]);

            let mut i = 0;
            while i < n {
                let mut w = F::ONE;
                for j in 0..m {
                    let a = input[(i + j + m) as usize] * w;
                    let b = input[(i + j) as usize] - a;
                    input[(i + j + m) as usize] = b;
                    input[(i + j) as usize] += a;
                    w *= w_m;
                }

                i += m << 1;
            }

            m <<= 1;
        }
    }

    /// This function produces the evaluations of Lagrange basis polynomials
    /// $\ell_i(x)$ for the domain generated by powers of `omega` where `omega` is
    /// an `n`-th primitive root of unity.
    ///
    /// The provided `n_inv` must be the inverse of `n` in the field.
    ///
    /// # Panics
    ///
    /// This function may panic if `omega` is not a `n`-th primitive root of unity
    /// or if `n_inv` is not the inverse of `n`.
    ///
    /// # Implementation
    ///
    /// The Lagrange basis polynomials are given for a domain $D$ of size $n$
    /// generated by powers of $\omega$ where $\omega$ is a primitive $n$-th root of
    /// unity. The vanishing polynomial for this domain is
    ///
    /// $$ v(X) = \prod_{i=0}^{n - 1} (X - \omega^i) = X^n - 1. $$
    ///
    /// and so the Lagrange basis polynomials are given by
    ///
    /// $$ \ell_i(X) = \frac{(X^n - 1) b_i}{X - \omega^i} $$
    ///
    /// where
    ///
    /// $$ b_i = \prod_{j=0, j \neq i}^{n - 1} (\omega^i - \omega^j)^{-1} =
    /// \frac{\omega^i}{n} $$
    ///
    /// is the barycentric weight of $\omega^i$. Thus, given some point $x \in
    /// \mathbb{F} \setminus D$ we can compute
    ///
    /// $$ \ell_i(x) = (x - \omega^i)^{-1} \cdot \frac{(x^n - 1) \omega^i}{n}.$$
    ///
    /// Most of the work of computing these values can be shared using Montgomery's
    /// trick.
    pub fn ell(&self, x: F) -> Vec<F> {
        if x.pow([self.n as u64]) == F::ONE {
            // It's part of the domain, let's figure out which one real quick.
            // TODO(ebfull): This can be done more efficiently by computing
            // the discrete log of x with respect to omega, or using a lookup
            // table.
            let mut evals = vec![F::ZERO; self.n];
            let mut omega_i = F::ONE;
            for eval in evals.iter_mut() {
                if omega_i == x {
                    *eval = F::ONE;
                    break;
                }
                omega_i *= self.omega;
            }
            return evals;
        }

        let mut denominators: Vec<F> = (0..self.n)
            .scan(F::ONE, |acc, _| {
                let tmp = x - *acc;
                *acc *= self.omega;
                Some(tmp)
            })
            .collect();
        {
            let mut scratch = denominators.clone();
            ff::BatchInverter::invert_with_external_scratch(&mut denominators, &mut scratch);
        }

        denominators
            .into_iter()
            .scan(
                (x.pow([self.n as u64]) - F::ONE) * self.n_inv,
                move |numerator, denominator| {
                    let tmp = (*numerator) * denominator;
                    *numerator *= self.omega;
                    Some(tmp)
                },
            )
            .collect()
    }
}

#[test]
fn test_fft() {
    use crate::eval;
    use ff::Field;
    use pasta_curves::Fp as F;

    let params = Domain::<F>::new(4);

    let coeffs = (0..params.n)
        .map(|i| F::DELTA.pow(&[(i + 1) as u64]))
        .collect::<Vec<_>>();
    let mut evals = coeffs.clone();

    params.fft(&mut evals);

    {
        let mut p = F::ONE;
        for i in 0..params.n {
            assert_eq!(evals[i as usize], eval(&coeffs, p));
            p *= params.omega;
        }
    }

    let mut coeffs_recovered = evals.clone();
    params.ifft(&mut coeffs_recovered);
    assert_eq!(coeffs, coeffs_recovered);
}

#[test]
fn test_ell() {
    use crate::eval;
    use ff::Field;
    use pasta_curves::Fp as F;

    let params = Domain::<F>::new(5);

    let mut lagrange_polys = vec![];
    for i in 0..params.n {
        let mut tmp = vec![F::ZERO; params.n];
        tmp[i] = F::ONE;
        assert_eq!(tmp, params.ell(params.omega.pow([i as u64]),));
        params.ifft(&mut tmp);
        assert_eq!(eval(&tmp, params.omega.pow([i as u64])), F::ONE);
        for j in 0..params.n {
            assert_eq!(
                eval(&tmp, params.omega.pow([j as u64])),
                if i == j { F::ONE } else { F::ZERO }
            );
        }
        lagrange_polys.push(tmp);
    }

    let x = F::DELTA;

    let expected = params.ell(x);
    for (i, expected) in expected.iter().enumerate() {
        assert_eq!(eval(&lagrange_polys[i], x), *expected);
    }
}
